---
title: '[항해 3주차] 회고록 Serverless와 DOM'
date: 2023-10-04 23:46
categories:
  - WIL
tags:
  - 항해99
---

이번 3 주차는 리엑트 입문 주차로 리엑트와 친해지기를 하는 주차이다. 하지만 이번 주까지 내야하는 개인 과제는 ‘월요일부터 일요일까지 평점을 매기는 사이트’를 만드는 아주 간단한 UI 였다. 하지만 나에게 다가온 난이도는 이미 절친이 되어야 풀 수 있는 문제인 듯했다.

아마 자바스크립트로 만들었다면 뚝딱 만들수 있는 난이도였지만, 이제 막 걸음을 시작하는 리엑트로는 거대한 산처럼 보였다.

그래도 한 번 부딪혀보자는 마음으로 제공해주신 리엑트 강의를 열심히 참고해서 리엑트와 억지로 친한 척(?) 하기에 돌입했다… 하지만 역시나 쉽지는 않았다.

useState나 useEffect 등 익숙치 않은 문법에 많이 어색하기도 했다. 그렇게 며칠동안 하니 어느정도 익숙해졌다.

그러다보니 생각보다 빠른 시간에 개인과제를 마무리 할 수 있었다. 그래서 옆에서 친해지지 못한 조원들과 친구들을 조금 도와줄 수 있었다.

이번에는 서버리스와 DOM 이라는 것을 배웠는데, 한 번 기록해보려 한다.

## 서버리스란? … 서버가 없는건가?

당연히 모든 기록은 저장할 곳이 필요하기 때문에 서버가 없을 순 없다. 그럼 서버리스란 무엇인가?

서버리스란 클라우드 컴퓨팅의 모델 중 하나로 사용자가 서버를 직접 관리할 필요가 없는 모델을 의미한다. 즉, 트래픽에 따라 사용자가 직접 서버의 가용량을 증/감 시킬 필요가 없다는 뜻 이다.

그저 MS, 아마존, 구글에게 돈만 주면 그들이 제공하는 짱짱한 서버를 이용 할 수 있게 된 것이다.

하지만 서버의 물리적인(하드웨어) 부분은 클라우드 서비스를 제공하는 기업이 직접 관리해주지만 여전히 서버의 소프트웨어적인 부분은 사용자가 직접 관리를 해야 합니다. 서버에 깔린 운영체제 등을 업데이트하고, 데이터를 백업하고, 보안에도 신경 써야 하는 등 생각보다 귀찮은 일이 많다.

서버리스는 동적으로 서버의 자원을 할당합니다.

즉 사용자가 없다면 자원을 할당하지 않고 대기하다가 요청이 들어오면 그 때 자원을 할당해서 요청을 처리하고 다시 대기 상태로 들어가게 됩니다. 자원을 효율적으로 사용할 수 있는 것입니다.

비용 또한 대기상태를 제외한 실제 사용 자원에 대해서만 청구가 되기 때문에 굉장히 경제적입니다.

게다가 이 서버는 클라우드 제공 기업에서 전적으로 관리하기 때문에 사용자는 스케일링, 업데이트, 보안 등 서버에 대해 일절 관리하거나 신경 쓸 필요가 없어집니다. 서버를 고려하지 않고 서비스와 애플리케이션에 집중할 수 있게 되는 것이죠.

요약하자면 '기존 클라우드 컴퓨팅 모델에 비해 경제적이고 가용성이 좋은 모델이 서버리스다' 라고 생각하시면 될 것 같습니다.

### 서버리스의 장점

1. 가격

- 기존 IaaS나 PaaS와는 다르게 실제 사용량에 대해서만 비용이 청구되므로 경제적입니다.

2. 애플리케이션의 품질에 집중 가능

- 서버에 신경 쓸 필요가 없어지므로 사용자는 개발하는 애플리케이션의 품질 향상에 좀 더 집중할 수 있습니다.

3. 높은 가용성과 유연한 확장

- 요청이 들어올때만 실행되고 동적으로 자원을 할당하기 때문에 가용성이 높고 스케일링에 신경 쓸 필요가 없습니다.

### 서버리스의 단점

1. Cold Start

- 아무래도 서버가 항시 요청에 대기하고 있는게 아니다보니 IaaS나 PaaS등의 모델보단 느립니다.

프로젝트 규모가 작다면 별로 신경쓸만한 사항은 아니지만 규모가 커지거나 속도를 요구하는 프로젝트라면 서버리스는 좋은 선택이 아닐 수 있습니다..

2. 클라우드 제공 플랫폼에 심하게 종속적

- 기존 IaaS나 PaaS모델은 플랫폼을 바꾸는게 어렵지 않지만(예시 : AWS에서 Google Cloud로) 서버리스는 애플리케이션의 구조 자체를 바꾸기 때문에 다른 플랫폼으로 이전하는게 굉장히 힘듭니다. 그리고 이는 곧 사용중인 플랫폼의 가격이나 정책, 서비스 변경에도 민감하게 반응해야됨을 의미합니다.

3. 긴 시간을 요하는 작업에 불리함

- 서버리스는 단순 작업(댓글 쓰기, 이메일 보내기 등)에는 적합하지만 긴 시간을 요하는 작업(동영상 업로드, 데이터 백업 등)에는 굉장히 비효율적입니다. 서버리스는 함수가 1회 호출 될 때 사용할 수 있는 메모리 및 시간에 제한이 있기 때문입니다. 작업이 끝나지 않은채로 해당 시간이 지나면 작업이 끝날때까지 일정 시간마다 계속 함수를 다시 호출하므로 굉장히 비효율적입니다.

## DOM 이란 무엇일까?

우선 DOM은 Document Object Model의 약자입니다. 그럼 문서 객체란 것이 무엇일까요? 문서 객체란 `<html>`이나 `<body>` 같은 html문서의 태그들을 JavaScript가 이용할 수 있는 객체(object)로 만들면 그것을 문서 객체라고 합니다.

그럼 html문서의 태그들이 객체에 담긴 상태를 의미하는 것일까요? 여기에 Model이란 어휘도 붙었는데 Model이라는 영어 단어에는 모형, 주형이라는 의미도 있고 모듈이라는 의미도 있습니다. 비슷하게 여기서는 문서 객체를 '인식하는 방식'이라고 해석할 수 있습니다.

이제 조금 더 명확하게 DOM을 정의해보겠습니다.

DOM은 넓은 의미로 웹 브라우저가 HTML 페이지를 인식하는 방식을 의미합니다. 조금 좁은 의미로 본다면 document 객체와 관련된 객체의 집합을 의미할 수도 있습니다.

![](https://velog.velcdn.com/images/gusdh2/post/0658f2bc-cad6-45b3-94eb-9120713f3f16/image.jpeg)

DOM을 제대로 이해하기 위해서는 tree라는 자료구조를 이해할 필요가 있습니다. DOM이 tree 형식의 자료구조를 가지고 있기 때문입니다.

​

tree의 자료구조를 간단히 설명하겠습니다. 이름에서 알 수 있는 것처럼 하나의 root node에서 시작됩니다. 그런데 나무는 땅에서 솟아서 점점 위로 뻗어나가지만 tree형 자료구조는 흔히 위의 root node에서 아래로 퍼져나가는 형태로 그립니다.

​

tree에서는 위쪽의 node를 부모(parent) 노드 아랫쪽 노드를 자식(child)라고 합니다. root node는 가장 위에서 시작되는 node이니까 parent가 없는 node가 됩니다. 그리고 children(자식)이 없는 node를 leaf node라고 합니다. 뿌리(root)에서 시작해서 잎(leaf)에서 끝나는 것이죠.

![](https://velog.velcdn.com/images/gusdh2/post/e1390538-41c8-47be-9619-fc7d77420b15/image.png)

DOM을 제대로 이해하기 위해서는 tree라는 자료구조를 이해할 필요가 있습니다. DOM이 tree 형식의 자료구조를 가지고 있기 때문입니다.

​

tree의 자료구조를 간단히 설명하겠습니다. 이름에서 알 수 있는 것처럼 하나의 root node에서 시작됩니다. 그런데 나무는 땅에서 솟아서 점점 위로 뻗어나가지만 tree형 자료구조는 흔히 위의 root node에서 아래로 퍼져나가는 형태로 그립니다.

​

tree에서는 위쪽의 node를 부모(parent) 노드 아랫쪽 노드를 자식(child)라고 합니다. root node는 가장 위에서 시작되는 node이니까 parent가 없는 node가 됩니다. 그리고 children(자식)이 없는 node를 leaf node라고 합니다. 뿌리(root)에서 시작해서 잎(leaf)에서 끝나는 것이죠.

### DOM은 어떻게 사용할까?

```js
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title> 문서객체 모델(DOM)</title >
<script type= "text/javascript">

</script>
</head>
<body>
   <h1 id ="header_1" name= "" >HEADER-1 </h1 >
   <div >
      <h1 id = "header_2">HEADER-2</h1 >
   </div >
   <hr >
   <h1 id = "clock"></h1>
</body>
</html>
```

아래의 HTML 문서를 웹 브라우저를 통해 보면 다음과 같습니다. ![](https://velog.velcdn.com/images/gusdh2/post/7cc6d207-d751-4f90-be8f-89b83ca79380/image.png)

여기서 이제 JavaScirpt를 통해서 동적으로 문서객체를 생성해보겠습니다.

```js
var header = document.createElement('h2');
```

우선 document 객체에 접근해서 `<h2>` 태그를 생성합니다.

```js
var textNode = document.createTextNode('Hello DOM');
```

그 다음은 document 객체에 접근해서 TextNode를 생성하고 'Hello DOM'이라는 스트링을 넣어주고 있습니다.

```js
header.appendChild(textNode);
```

위에서 생성한 `<h2>` 태그에 자식노드를 추가하고 있습니다. 그런데 그 추가되는 자식노드가 아까 위해서 생성한 Text Node이네요!

```js
document.body.appendChild(header);
```

이제 document객체를 통해서 body 객체에 접근하고 있네요. 그리고 body객체에 자식 노드를 추가하고 있는데 아까 `<h2>` 태그를 생성해서 TextNode까지 추가했던 header네요. 이렇게 추가하고 나면 위의 그림에서 아래처럼 문자가 추가된 것을 확인할 수 있습니다.

![](https://velog.velcdn.com/images/gusdh2/post/13a505e1-c190-4e40-8e31-d9f0327a6ee6/image.png)

아래는 JavaScript를 추가한 코드입니다. (여기서는 `<script>`태그의 위치가 `<body>` 태그보다 위이기 때문에 onload 메소드를 사용하지 않으면 에러가 나기 때문에 사용하고 있습니다.))

```js

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title> 문서객체 모델(DOM)</title >
<script type= "text/javascript">
    window.onload = function(){
       //1. 문서 객체 생성
       var header = document.createElement('h2'); //h2 태그를 생성해주는 것
       var textNode = document.createTextNode('Hello DOM');

       //2. 노드(요소/텍스트)를 연결.
       header.appendChild(textNode);

       //3. body 문서 객체에 header 문서 객체를 추가.
       document.body.appendChild(header);
    };
</script>
</head>
<body>
   <h1 id ="header_1" name= "" >HEADER-1 </h1 >
   <div >
      <h1 id = "header_2">HEADER-2</h1 >
   </div >
   <hr >
   <h1 id = "clock"></h1>
</body>
</html>
```
